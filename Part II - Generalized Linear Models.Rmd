---
title: "Part II: Generalized Linear Models"
output:
  pdf_document: default
  html_document: default
---

# Load Packages 

Again, we must load the packages that will be used in the first part of this workshop.


```{r, message=FALSE, warning=FALSE }
library(pastecs, quietly = TRUE)
library(lm.beta,  quietly = TRUE)
library(lmtest,  quietly = TRUE)
library(foreign,  quietly = TRUE)
library(lattice,  quietly = TRUE)
library(lme4,  quietly = TRUE)
library(nlme,  quietly = TRUE)
library(survival,  quietly = TRUE)
library(dplyr,  quietly = TRUE)
library(ggfortify,  quietly = TRUE)
library(survminer,  quietly = TRUE)
library(rms,  quietly = TRUE)
library(MASS, quietly = TRUE)
```

# Generalized linear models

A generalized linear model (GLM) has three:

- a random component with mean $\mu$. Generally, the random component is the response variable $Y_i.$
- a systematic component, $\eta_i$, that relates the relates the explanatory variables,
$$\eta_i = \sum_{j=i}^{n} \beta_j x_{ij}$$
- a link function that relates the mean of the random to the systematic component
$$g(\mu) = \eta_i$$

# Logistic regression

Logistic regression is a GLM used the model binary (0 or 1) data. The response variable must be binary and is assumed to follow a bernoulli distribution. 

That said, logistic regression has the following properties:
-  a response binary variable, $Y_i$, that follows a bernoulli distribution with mean $\pi_i$.
- a systematic component, $\eta_i$, that relates the relates the explanatory variables,
$$\eta_i = \sum_{j=1}^{n} \beta_j x_{ij}$$
- a link function that relates the mean of the random to the systematic component
$$\log\left(\frac{\pi_i}{1-\pi_i}\right) = \sum_{j=i}^{n} \beta_j x_{ij}.$$ $\log\left(\frac{\pi_i}{1-\pi_i}\right)$ is known as the log odds.

## Data 

Using the iris data, we create binary data. We add the column `Sepal.Width_binary` to iris. If the `Sepal.Width` is greater than the median then the associated value in `Sepal.Width_binary` is 1. Otherwise, `Sepal.Width_binary` is 0.

```{r}
data <- iris
data$Sepal.Width_binary <- ifelse(data$Sepal.Width >= median(data$Sepal.Width), 1, 0)
```

## Logistic Regression with only the constant term

Fitting only a constant term, the systematic component is
$$\eta_i = \beta_0$$
```{r}
logit <- glm(Sepal.Width_binary ~ 1, data = data, family = "binomial")
summary(logit)
```

```{r}
p_avg <- mean(data$Sepal.Width_binary)
log_odds_avg <- log(p_avg/(1-p_avg))
print(log_odds_avg)
```

## Logistic Regression with Species  

Fitting the species term, the systematic component is
$$\eta_i = 1 + \beta_2 X_{1i} + \beta_3 X_{2i}.$$

where 
$$  X_{1i} = \begin{cases} 1 & \text{if } i\text{th data point is versicolor}\\ 0 &  \text{otherwise}\end{cases}, \, X_{2i} = \begin{cases} 1 & \text{if } i \text{th data point is virginica}\\ 0 & \text{otherwise}\end{cases}$$


```{r}
logit <- glm(Sepal.Width_binary ~ as.factor(Species), data = data, family = "binomial")
summary(logit)
```

Let's compare the results to the average log odds of each Species group
```{r}
log_odds_avg_fun <- function(data){
  p_avg <- mean(data)
  log_odds_avg <- log(p_avg/(1-p_avg))
  return(log_odds_avg)
}

tapply(data$Sepal.Width_binary,
       data$Species, log_odds_avg_fun)
```

The intercept corresponds to the average log odds of setosa as we would expect. However, the other coefficients do not correspond to the average log odds of the other species. Why?

From the formula, $\eta_i = 1 + \beta_2 X_{2i} + \beta_3 X_{3i}$, the log odds of versicolor actually corresponds to $1+\beta_2$. The log odds of versicolor actually corresponds to $1+\beta_3$.

```{r}
coefficients<-unname(coef(logit))
print(c(coefficients[1],coefficients[1]+coefficients[2],
        coefficients[1]+coefficients[3]))
```

## Logistic Regression with Sepal.Length

Fitting the species term, the systematic component is

$$\eta_i =  \beta_3 X_{1i}.$$

where 
$$  X_{1i} = \begin{cases} 1 & \text{if } i\text{th data point is versicolor}\\ 0 &  \text{otherwise}\end{cases}, \, X_{2i} = \begin{cases} 1 & \text{if } i \text{th data point is virginica}\\ 0 & \text{otherwise}\end{cases}$$ and $X_{3i} = \text{Sepal.Length of the }i\text{th  data point}.$

```{r}
logit <- glm(Sepal.Width_binary ~ Sepal.Length, 
             data = data, family = "binomial")
summary(logit)
```


```{r}
plot(Sepal.Width_binary~Sepal.Length, data=data)
points(data$Sepal.Length[order(data$Sepal.Length)],
       logit$fitted[order(data$Sepal.Length)],  col="red")
title(main="Data with Fitted Logistic Regression Line")
```

## Logistic Regression with Species and Sepal.Length

Fitting the species term, the systematic component is
$$\eta_i = 1 + \beta_2 X_{1i} + \beta_3 X_{2i} + \beta_3 X_{3i}.$$

where 
$$  X_{1i} = \begin{cases} 1 & \text{if } i\text{th data point is versicolor}\\ 0 &  \text{otherwise}\end{cases}, \, X_{2i} = \begin{cases} 1 & \text{if } i \text{th data point is virginica}\\ 0 & \text{otherwise}\end{cases}$$ and $X_{3i} = \text{Sepal.Length of the }i\text{th  data point}.$

Fitting the logistic model accordingly,

```{r}
logit <- glm(Sepal.Width_binary ~ Species +Sepal.Length, 
             data = data, family = "binomial")
summary(logit)
```
Plot the results for each species, we get that
```{r}
plot(data[data$Species == "setosa", ]$Sepal.Length, 
     data[data$Species == "setosa", ]$Sepal.Width_binary, 
     xlim=as.matrix(range(data$Sepal.Length)),
     xlab = 'Sepal Length',  ylab= 'Sepal Width binary',
     main= 'Scatter plot of sepal length vs sepal width')

points(data$Sepal.Length[data$Species == "setosa"],
       logit$fitted[data$Species == "setosa"],  pch=15,
       col="red")
```

```{r}
plot(data[data$Species == "versicolor", ]$Sepal.Length,
     data[data$Species == "versicolor", ]$Sepal.Width_binary,
     xlim=as.matrix(range(data$Sepal.Length)),
     xlab = 'Sepal Length',  ylab= 'Sepal Width binary',
     main= 'Scatter plot of sepal length vs sepal width')

points(data$Sepal.Length[data$Species == "versicolor"],
       logit$fitted[data$Species == "versicolor"],  pch=15,
       col="yellow")
```

```{r}
plot(data[data$Species == "virginica", ]$Sepal.Length,
     data[data$Species == "virginica", ]$Sepal.Width_binary,
     xlim=as.matrix(range(data$Sepal.Length)),
     xlab = 'Sepal Length',  ylab= 'Sepal Width binary',
     main= 'Scatter plot of sepal length vs sepal width')

points(data$Sepal.Length[data$Species == "virginica"],
       logit$fitted[data$Species == "virginica"],  pch=15,
       col="blue")
```


## Deviance

 For general linear models, we use *deviance* to the compare to two different models. Deviance is the difference in log likelihood of the models multipled by 2.
 
### Saturated Model
 
Let's consider model in which each data point has its own mean and coefficients. This is called the saturated model. It basically replicates the data at hand. 

Using deviance, we can compare our fitted model to a saturated model. If the fitted model is behaves similiar to the saturated model, then the deviance can be well approximated by a chi-squared distribution with $m-n$ degrees of freedom. $m$ is number of the data points and $n$ is number of coefficients in our fitted model.

This satistical property of the deviance allows us perform a hypothesis test

$$H_0:\text{ the fitted model  is equivalent to the saturated model }$$
$$H_{\alpha}:\text{the fitted model is not equivalent to the saturated model}$$

`logit$deviance` is the deviance between saturated model and fitted model. `logit$df.residual` is equal to number of observations minus the number of coefficients in the fitted model. Using this, we can calculate the p value for the hypothesis test above.

```{r}
p_value = pchisq(logit$deviance, 
                 logit$df.residual, lower.tail = F)
print(p_value)
```

Since the p value is less than 0.05, we fail to reject the null hypothesis. (This is a good thing.)

### Null Model

We can also use deviance to determine if our fitted model is better than the null model. The null model is  is a model with only a linear term. Like above, we can design a hypothesis test comparing the null model to the fitted model.



$$H_0 = \text{ the fitted model  is equivalent to the null model }$$
$$H_{\alpha} = \text{ the fitted model  is not equivalent to the null model } $$

In the limit of large data, it is known that the deviance follows a chi-squared distribution with parameter $n-1.$

`logit$deviance` is the deviance between saturated model and fitted model. `logit$df.residual` is equal to number of observations minus the number of coefficients in the fitted model. 

`logit$null.deviance` is the deviance between saturated model and the null model. `logit$df.null` is the number of observations minus 1.

Using this information, we can calculate the p value for the hypothesis test above.


```{r}
p_value = pchisq(logit$null.deviance-logit$deviance,
                 logit$df.null-logit$df.residual, lower.tail = F)
print(p_value)
```

Since the p value is less than one, we reject our null hypothesis. (This is a good thing.)

### Anova 

Sequencial comparison of model terms by deviance

```{r}
anova(logit,test="Chisq")
```


\newpage

# Poisson Regression



```{r}
attach(colon)
summary(colon)
```

```{r}
colon_data <- na.omit(colon)
sapply(colon_data, class)
```

```{r}
colon_data$age.ds = sapply(colon_data$age,
                          function(x) ifelse(x > median(age), 1, 0))
colon_data$age.ds <- factor(colon_data$age.ds, 
                            levels= c("0","1"),
                            labels=c("<median",">median"))
```

```{r}
colon_data$node4 <- factor(colon_data$node4, 
                          levels= c("0","1"), 
                          labels=c("<4",">4"))
```

```{r}
colon_data$sex <- factor(colon_data$sex,
                        levels= c("0","1"), labels=c("F","M"))
```

```{r}
colon_data$obstruct <- factor(colon_data$obstruct,
                             levels= c("0","1"),
                            labels=c("no obstruct","obstruct"))
colon_data$adhere <- factor(colon_data$adhere,
                            levels= c("0","1"),
                            labels=c("no adhere","adhere"))
colon_data$perfor <- factor(colon_data$perfor, 
                            levels= c("0","1"), 
                            labels=c("no perfor","perfor"))
```

```{r}
colon_data$differ <- factor(colon_data$differ,
                            levels= c("1","2","3"),
                            labels=c("well","mod","poor"))
colon_data$extent <- factor(colon_data$extent, 
                            levels= c("1","2","3","4"),
                            labels=c("submucosa", "muscle", "serosa", "contiguous"))
colon_data$surg <- factor(colon_data$surg,
                          levels= c("0","1"), 
                          labels=c("short","long"))
```

```{r}
ggplot(colon_data,aes(x=colon_data$nodes))+ 
  geom_histogram(binwidth = 1, center = 1) +
  scale_x_continuous(breaks=seq(0,max(colon_data$nodes), by = 1))+
  ylab("Count")+ xlab("data")+
  ggtitle("Histogram plot of the number of epileptic seizures")
```

```{r}
poisson_model = glm(nodes ~ 1, family=poisson(link=log),data=colon_data)
summary(poisson_model)
```


```{r}
print(coef(poisson_model))
```

```{r}
head(data.frame(colon_data$nodes,poisson_model$fitted))
```

```{r}
head(poisson_model$linear.predictors)
head(exp(poisson_model$linear.predictors))
```
## Hypothesis test for goodness of fit

```{r}
p_value = pchisq(poisson_model$deviance,
                 poisson_model$df.residual, lower.tail = F)
print(p_value)
```


```{r}
p_value = pchisq(poisson_model$null.deviance-logit$deviance,
                poisson_model$df.null-logit$df.residual, lower.tail = F)
print(p_value)
```


## add a Covariate to the fit -- treatment
```{r}
poisson_model = glm(nodes~ 1 + rx, family=poisson(link=log),data=colon_data)
summary(poisson_model)
```

```{r}
plot(colon_data$nodes)
points(poisson_model$fitted,col="red")
```

## Hypothesis test for goodness of fit

```{r}
p_value = pchisq(poisson_model$deviance,
                 poisson_model$df.residual, lower.tail = F)
print(p_value)
```


```{r}
p_value = pchisq(poisson_model$null.deviance-logit$deviance,
                poisson_model$df.null-logit$df.residual, lower.tail = F)
print(p_value)
```

```{r}
anova(poisson_model,test="Chisq")
```



### add a Covariate to the fit -- treatment, time

```{r}
poisson_model = glm(nodes ~ 1 + rx + time,
                    family=poisson(link=log),data=colon_data)
summary(poisson_model)
```

## Hypothesis test for goodness of fit

```{r}
p_value = pchisq(poisson_model$deviance,
                 poisson_model$df.residual, lower.tail = F)
print(p_value)
```


```{r}
p_value = pchisq(poisson_model$null.deviance-logit$deviance,
                poisson_model$df.null-logit$df.residual, lower.tail = F)
print(p_value)
```

```{r}
anova(poisson_model,test="Chisq")
```

### add a Covariate to the fit -- treatment, time interaction

```{r}
poisson_model = glm(nodes ~ 1 + rx*time,
                    family=poisson(link=log),data=colon_data)
summary(poisson_model)
```

```{r}
p_value = pchisq(poisson_model$deviance,
                 poisson_model$df.residual, lower.tail = F)
print(p_value)
```

```{r}
p_value = pchisq(poisson_model$null.deviance-logit$deviance,
                poisson_model$df.null-logit$df.residual, lower.tail = F)
print(p_value)
```

```{r}
anova(poisson_model,test="Chisq")
```

\newpage

# Log-Linear Regression

Log-linear models allow us to model asscociation between between two or more variables in contingency table. In a log-linear model, there are no well defined explanatory/response variables. This is because we are focused more on the *interaction* between two variables.

## Contingency Table

Contingency table displays number of observations for a given combination of factors.

This definition is best represented by an example. 

```{r}
epil$y_binary <- sapply(epil$y,function(x) ifelse(x > median(epil$y), 1, 0))
```

### One-Way Contingency Table
```{r}
table(y_relative_median=epil$y_binary)
```

## Two-Way Contingency Table
```{r}
table(y_relative_median=epil$y_binary,period=epil$period)
```

### Independent Model

```{r}
contigency_table = table(y_relative_median=epil$y_binary,period=epil$period)
```

Need to convert contigency table in a form that is acceptable to `glm`
```{r}
contigency_table.df = as.data.frame(contigency_table)
```

```{r}
log_linear_model <- glm(Freq ~ y_relative_median + period, 
            data = contigency_table.df, family = poisson)
```

```{r}
summary(log_linear_model)
```
### Saturated Model

```{r}
log_linear_model <- glm(Freq ~ period*y_relative_median, 
            data = contigency_table.df, family = poisson)
```


```{r}
summary(log_linear_model)
```
```{r}
anova(log_linear_model,test='Chisq')
```

## Three-Way Contingency Table
```{r}
table(y_relative_median=epil$y_binary,period=epil$period,trt=epil$trt)
```

### Independent Model
```{r}
contigency_table = table(y_relative_median=epil$y_binary,
                         period=epil$period,trt=epil$trt)
```

Need to convert contigency table in a form that is acceptable to `glm`
```{r}
contigency_table.df = as.data.frame(contigency_table)
```

```{r}
log_linear_model <- glm(Freq ~ y_relative_median + period + trt, 
            data = contigency_table.df, family = poisson)
```

```{r}
summary(log_linear_model)
```

### Saturated Model

```{r}
log_linear_model <- glm(Freq ~ period*y_relative_median*trt, 
            data = contigency_table.df, family = poisson)
```


```{r}
summary(log_linear_model)
```

```{r}
anova(log_linear_model,test='Chisq')
```